package com.webweeb.backend.service;import com.webweeb.backend.dto.UserDTO;import com.webweeb.backend.entity.DeviceToken;import com.webweeb.backend.entity.LoginHistory;import com.webweeb.backend.entity.Role;import com.webweeb.backend.entity.User;import com.webweeb.backend.enums.RoleType;import com.webweeb.backend.exception.AppException;import com.webweeb.backend.repository.DeviceTokenRepo;import com.webweeb.backend.repository.LoginHistoryRepo;import com.webweeb.backend.repository.RoleRepo;import com.webweeb.backend.repository.UserRepo;import com.webweeb.backend.security.JwtUtil;import com.webweeb.backend.utils.Mail;import jakarta.transaction.Transactional;import lombok.extern.slf4j.Slf4j;import org.modelmapper.ModelMapper;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.http.HttpStatus;import org.springframework.security.authentication.BadCredentialsException;import org.springframework.security.core.context.SecurityContextHolder;import org.springframework.security.core.userdetails.UserDetails;import org.springframework.security.core.userdetails.UserDetailsService;import org.springframework.security.core.userdetails.UsernameNotFoundException;import org.springframework.security.crypto.password.PasswordEncoder;import org.springframework.stereotype.Service;import java.util.List;import java.util.Map;import java.util.UUID;@Slf4j@Servicepublic class UserService implements UserDetailsService {    @Autowired    private UserRepo userRepo;    @Autowired    private PasswordEncoder passwordEncoder;    @Autowired    private JwtUtil jwtUtil;    @Autowired    private ModelMapper modelMapper;    @Autowired    private LoginHistoryRepo loginHistoryRepo;    @Autowired    private Mail mail;    @Autowired    private RoleRepo roleRepo;    @Autowired    private DeviceTokenRepo deviceTokenRepo;    public static LoginHistory getLoginHistory(UserDTO userDTO, User existingUser) {        LoginHistory loginHistory = new LoginHistory();        loginHistory.setUser(existingUser);        loginHistory.setIpAddress(userDTO.getIpAddress());        loginHistory.setUserAgent(userDTO.getUserAgent());        loginHistory.setDeviceName(userDTO.getDeviceName());        loginHistory.setDeviceType(userDTO.getDeviceType());        loginHistory.setOsName(userDTO.getOsName());        loginHistory.setOsVersion(userDTO.getOsVersion());        loginHistory.setBrowserName(userDTO.getBrowserName());        loginHistory.setBrowserVersion(userDTO.getBrowserVersion());        loginHistory.setLocation(userDTO.getLocation());        return loginHistory;    }    @Override    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {        return userRepo.findByUsernameOrEmail(username, username)                .orElseThrow(() -> new UsernameNotFoundException("User not found"));    }    @Transactional    public Object registerUser(UserDTO userDTO) {        if (userRepo.existsByUsernameOrEmail(userDTO.getUsername(), userDTO.getEmail())) {            throw new IllegalArgumentException("Username or email already in use");        }        String rawPassword = userDTO.getPassword();        userDTO.setPassword(passwordEncoder.encode(userDTO.getPassword()));        User user = modelMapper.map(userDTO, User.class);        Role defaultRole = roleRepo.findByName(RoleType.USER)                .orElseGet(() -> roleRepo.saveAndFlush(new Role(RoleType.USER)));        user.getRoles().add(defaultRole);        user.setSecretKey(UUID.randomUUID());        User savedUser = userRepo.save(user);        log.info("User registered successfully: {}", savedUser.getUsername());        UserDTO loginDTO = new UserDTO();        modelMapper.map(userDTO, loginDTO);        loginDTO.setUsername(userDTO.getUsername());        loginDTO.setPassword(rawPassword);        return loginUser(loginDTO);    }    @Transactional    public Object loginUser(UserDTO userDTO) {        UserDTO user = modelMapper.map(userRepo.findByUsernameOrEmail(userDTO.getUsername(), userDTO.getEmail())                .orElseThrow(() -> new UsernameNotFoundException("User not found")), UserDTO.class);        User existingUser = userRepo.findByUsernameOrEmail(userDTO.getUsername(), userDTO.getEmail())                .orElseThrow(() -> new UsernameNotFoundException("User not found"));        DeviceToken existingDeviceToken = deviceTokenRepo.findByUserAndDeviceType(existingUser, userDTO.getDeviceType())                .orElse(null);        if (existingDeviceToken != null && !existingDeviceToken.isActive()) {            throw new AppException("This device is not allowed to log in. Please check your device.", HttpStatus.FORBIDDEN);        }        if (existingDeviceToken == null) {            String deviceToken = generateDeviceToken(existingUser);            DeviceToken newDeviceToken = DeviceToken.builder()                    .user(existingUser)                    .deviceType(userDTO.getDeviceType())                    .token(deviceToken)                    .active(true)                    .build();            deviceTokenRepo.save(newDeviceToken);        }        if (passwordEncoder.matches(userDTO.getPassword(), user.getPassword())) {            String token = jwtUtil.generateToken(user.getUsername());            log.info("User logged in: {}", token);            return Map.of(                    "data", user,                    "token", token            );        } else {            throw new BadCredentialsException("Invalid username or password");        }    }    public UserDTO getProfile() {        String username = getAuthenticatedUsername();        User user = userRepo.findByUsernameOrEmail(username, username)                .orElseThrow(() -> new UsernameNotFoundException("User not found"));        return modelMapper.map(user, UserDTO.class);    }    public String getAuthenticatedUsername() {        Object principal = SecurityContextHolder.getContext().getAuthentication().getPrincipal();        if (principal instanceof UserDetails) {            return ((UserDetails) principal).getUsername();        } else {            return principal.toString();        }    }    private String generateDeviceToken(User user) {        return UUID.randomUUID().toString();    }}